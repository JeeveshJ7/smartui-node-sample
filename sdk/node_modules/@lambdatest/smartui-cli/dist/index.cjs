#!/usr/bin/env node
'use strict';

var commander = require('commander');
var which = require('which');
var listr2 = require('listr2');
var chalk7 = require('chalk');
var path2 = require('path');
var fastify = require('fastify');
var fs5 = require('fs');
var Ajv = require('ajv');
var addErrors = require('ajv-errors');
var winston = require('winston');
var FormData = require('form-data');
var axios = require('axios');
var child_process = require('child_process');
var spawn = require('cross-spawn');
var test = require('@playwright/test');
var sharp = require('sharp');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var which__default = /*#__PURE__*/_interopDefault(which);
var chalk7__default = /*#__PURE__*/_interopDefault(chalk7);
var path2__default = /*#__PURE__*/_interopDefault(path2);
var fastify__default = /*#__PURE__*/_interopDefault(fastify);
var fs5__default = /*#__PURE__*/_interopDefault(fs5);
var Ajv__default = /*#__PURE__*/_interopDefault(Ajv);
var addErrors__default = /*#__PURE__*/_interopDefault(addErrors);
var FormData__default = /*#__PURE__*/_interopDefault(FormData);
var axios__default = /*#__PURE__*/_interopDefault(axios);
var spawn__default = /*#__PURE__*/_interopDefault(spawn);
var sharp__default = /*#__PURE__*/_interopDefault(sharp);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/lib/constants.ts
var constants_default = {
  // default configs
  DEFAULT_CONFIG: {
    web: {
      browsers: [
        "chrome",
        "firefox",
        "safari",
        "edge"
      ],
      viewports: [
        [1920],
        [1366],
        [1028]
      ]
    },
    mobile: {
      devices: [
        "iPhone 14",
        "Galaxy S24"
      ],
      fullPage: true,
      orientation: "portrait"
    },
    waitForTimeout: 1e3,
    enableJavaScript: false,
    allowedHostnames: []
  },
  DEFAULT_WEB_STATIC_CONFIG: [
    {
      "name": "lambdatest-home-page",
      "url": "https://www.lambdatest.com",
      "waitForTimeout": 1e3
    },
    {
      "name": "example-page",
      "url": "https://example.com/"
    }
  ],
  // browsers
  CHROME: "chrome",
  SAFARI: "safari",
  FIREFOX: "firefox",
  EDGE: "edge",
  EDGE_CHANNEL: "msedge",
  WEBKIT: "webkit",
  // user agents
  CHROME_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.107 Safari/537.3",
  FIREFOX_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:112.0) Gecko/20100101 Firefox/112.0",
  SAFARI_USER_AGENT: "Mozilla/5.0 (Macintosh; Intel Mac OS X 13_3) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15",
  EDGE_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.35",
  // viewports
  MIN_VIEWPORT_HEIGHT: 1080,
  // mobile
  MOBILE_OS_ANDROID: "android",
  MOBILE_OS_IOS: "ios",
  MOBILE_ORIENTATION_PORTRAIT: "portrait",
  MOBILE_ORIENTATION_LANDSCAPE: "landscape",
  // CI
  GITHUB_API_HOST: "https://api.github.com",
  // log file path
  LOG_FILE_PATH: ".smartui.log",
  // Disallowed file extension
  FILE_EXTENSION_ZIP: ".zip",
  FILE_EXTENSION_GIFS: "gif",
  // Default scrollTime
  DEFAULT_SCROLL_TIME: 8,
  // Magic Numbers 
  MAGIC_NUMBERS: [
    { ext: "jpg", magic: Buffer.from([255, 216, 255]) },
    { ext: "jpeg", magic: Buffer.from([255, 216, 255]) },
    { ext: "png", magic: Buffer.from([137, 80, 78, 71, 13, 10, 26, 10]) },
    { ext: "gif", magic: Buffer.from([71, 73, 70, 56]) }
  ],
  SUPPORTED_MOBILE_DEVICES: {
    "Blackberry KEY2 LE": { os: "android", viewport: { width: 412, height: 618 } },
    "Galaxy A12": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy A21s": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A22": { os: "android", viewport: { width: 358, height: 857 } },
    "Galaxy A31": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A32": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A51": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A7": { os: "android", viewport: { width: 412, height: 846 } },
    "Galaxy A70": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A8": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy A8 Plus": { os: "android", viewport: { width: 412, height: 846 } },
    "Galaxy J7 Prime": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy M12": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy M31": { os: "android", viewport: { width: 412, height: 892 } },
    "Galaxy Note10": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy Note10 Plus": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy Note20": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy Note20 Ultra": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy S10": { os: "android", viewport: { width: 360, height: 760 } },
    "Galaxy S10 Plus": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy S10e": { os: "android", viewport: { width: 412, height: 740 } },
    "Galaxy S20": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S20 FE": { os: "android", viewport: { width: 412, height: 914 } },
    "Galaxy S20 Ultra": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy S20 Plus": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S21": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S21 FE": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S21 Ultra": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S21 Plus": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S22": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S22 Ultra": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S23": { os: "android", viewport: { width: 360, height: 645 } },
    "Galaxy S23 Plus": { os: "android", viewport: { width: 360, height: 648 } },
    "Galaxy S23 Ultra": { os: "android", viewport: { width: 384, height: 689 } },
    "Galaxy S24": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S24 Plus": { os: "android", viewport: { width: 384, height: 832 } },
    "Galaxy S24 Ultra": { os: "android", viewport: { width: 384, height: 832 } },
    "Galaxy S7": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy S7 Edge": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy S8": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S8 Plus": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S9": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S9 Plus": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy Tab A7 Lite": { os: "android", viewport: { width: 534, height: 894 } },
    "Galaxy Tab A8": { os: "android", viewport: { width: 800, height: 1280 } },
    "Galaxy Tab S3": { os: "android", viewport: { width: 1024, height: 768 } },
    "Galaxy Tab S4": { os: "android", viewport: { width: 712, height: 1138 } },
    "Galaxy Tab S7": { os: "android", viewport: { width: 800, height: 1192 } },
    "Galaxy Tab S8": { os: "android", viewport: { width: 753, height: 1205 } },
    "Galaxy Tab S8 Plus": { os: "android", viewport: { width: 825, height: 1318 } },
    "Huawei Mate 20 Pro": { os: "android", viewport: { width: 360, height: 780 } },
    "Huawei P20 Pro": { os: "android", viewport: { width: 360, height: 747 } },
    "Huawei P30": { os: "android", viewport: { width: 360, height: 780 } },
    "Huawei P30 Pro": { os: "android", viewport: { width: 360, height: 780 } },
    "Microsoft Surface Duo": { os: "android", viewport: { width: 1114, height: 705 } },
    "Moto G7 Play": { os: "android", viewport: { width: 360, height: 760 } },
    "Moto G9 Play": { os: "android", viewport: { width: 393, height: 786 } },
    "Moto G Stylus (2022)": { os: "android", viewport: { width: 432, height: 984 } },
    "Nexus 5": { os: "android", viewport: { width: 360, height: 640 } },
    "Nexus 5X": { os: "android", viewport: { width: 412, height: 732 } },
    "Nokia 5": { os: "android", viewport: { width: 360, height: 640 } },
    "Nothing Phone (1)": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus 10 Pro": { os: "android", viewport: { width: 412, height: 919 } },
    "OnePlus 11": { os: "android", viewport: { width: 360, height: 804 } },
    "OnePlus 6": { os: "android", viewport: { width: 412, height: 869 } },
    "OnePlus 6T": { os: "android", viewport: { width: 412, height: 892 } },
    "OnePlus 7": { os: "android", viewport: { width: 412, height: 892 } },
    "OnePlus 7T": { os: "android", viewport: { width: 412, height: 914 } },
    "OnePlus 8": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus 9": { os: "android", viewport: { width: 411, height: 915 } },
    "OnePlus 9 Pro": { os: "android", viewport: { width: 412, height: 919 } },
    "OnePlus Nord": { os: "android", viewport: { width: 412, height: 914 } },
    "OnePlus Nord 2": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus Nord CE": { os: "android", viewport: { width: 412, height: 915 } },
    "Oppo A12": { os: "android", viewport: { width: 360, height: 760 } },
    "Oppo A15": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo A54": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo A5s": { os: "android", viewport: { width: 360, height: 760 } },
    "Oppo F17": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo K10": { os: "android", viewport: { width: 360, height: 804 } },
    "Pixel 3": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 3 XL": { os: "android", viewport: { width: 412, height: 846 } },
    "Pixel 3a": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 4": { os: "android", viewport: { width: 392, height: 830 } },
    "Pixel 4 XL": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 4a": { os: "android", viewport: { width: 393, height: 851 } },
    "Pixel 5": { os: "android", viewport: { width: 393, height: 851 } },
    "Pixel 6": { os: "android", viewport: { width: 393, height: 786 } },
    "Pixel 6 Pro": { os: "android", viewport: { width: 412, height: 892 } },
    "Pixel 7": { os: "android", viewport: { width: 412, height: 915 } },
    "Pixel 7 Pro": { os: "android", viewport: { width: 412, height: 892 } },
    "Pixel 8": { os: "android", viewport: { width: 412, height: 915 } },
    "Pixel 8 Pro": { os: "android", viewport: { width: 448, height: 998 } },
    "Poco M2 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "POCO X3 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "Realme 5i": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme 7i": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme 8i": { os: "android", viewport: { width: 360, height: 804 } },
    "Realme C21Y": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme C21": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme GT2 Pro": { os: "android", viewport: { width: 360, height: 804 } },
    "Redmi 8": { os: "android", viewport: { width: 360, height: 760 } },
    "Redmi 9": { os: "android", viewport: { width: 360, height: 800 } },
    "Redmi 9C": { os: "android", viewport: { width: 360, height: 800 } },
    "Redmi Note 10 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "Redmi Note 8": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 8 Pro": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 9": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 9 Pro Max": { os: "android", viewport: { width: 393, height: 873 } },
    "Redmi Y2": { os: "android", viewport: { width: 360, height: 720 } },
    "Tecno Spark 7": { os: "android", viewport: { width: 360, height: 800 } },
    "Vivo Y22": { os: "android", viewport: { width: 385, height: 860 } },
    "Vivo T1": { os: "android", viewport: { width: 393, height: 873 } },
    "Vivo V7": { os: "android", viewport: { width: 360, height: 720 } },
    "Vivo Y11": { os: "android", viewport: { width: 360, height: 722 } },
    "Vivo Y12": { os: "android", viewport: { width: 360, height: 722 } },
    "Vivo Y20g": { os: "android", viewport: { width: 385, height: 854 } },
    "Vivo Y50": { os: "android", viewport: { width: 393, height: 786 } },
    "Xiaomi 12 Pro": { os: "android", viewport: { width: 412, height: 915 } },
    "Xperia Z5": { os: "android", viewport: { width: 360, height: 640 } },
    "Xperia Z5 Dual": { os: "android", viewport: { width: 360, height: 640 } },
    "Zenfone 6": { os: "android", viewport: { width: 412, height: 892 } },
    "iPad 10.2 (2019)": { os: "ios", viewport: { width: 810, height: 1080 } },
    "iPad 10.2 (2020)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad 10.2 (2021)": { os: "ios", viewport: { width: 810, height: 1080 } },
    "iPad 9.7 (2017)": { os: "ios", viewport: { width: 768, height: 1024 } },
    "iPad Air (2019)": { os: "ios", viewport: { width: 834, height: 1112 } },
    "iPad Air (2020)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPad Air (2022)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPad mini (2019)": { os: "ios", viewport: { width: 768, height: 1024 } },
    "iPad mini (2021)": { os: "ios", viewport: { width: 744, height: 1133 } },
    "iPad Pro 11 (2021)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad Pro 11 (2022)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad Pro 12.9 (2018)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2020)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2021)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2022)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPhone 11": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 11 Pro": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 11 Pro Max": { os: "ios", viewport: { width: 414, height: 896 } },
    "iPhone 12": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 12 Mini": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 12 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 12 Pro Max": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 13": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Mini": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Pro Max": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 14": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 14 Plus": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 14 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 14 Pro Max": { os: "ios", viewport: { width: 428, height: 928 } },
    "iPhone 15": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 15 Plus": { os: "ios", viewport: { width: 430, height: 932 } },
    "iPhone 15 Pro": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 15 Pro Max": { os: "ios", viewport: { width: 430, height: 932 } },
    "iPhone 6": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 6s": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 6s Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone 7": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 7 Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone 8": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 8 Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone SE (2016)": { os: "ios", viewport: { width: 320, height: 568 } },
    "iPhone SE (2020)": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone SE (2022)": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone X": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone XR": { os: "ios", viewport: { width: 414, height: 896 } },
    "iPhone XS": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone XS Max": { os: "ios", viewport: { width: 414, height: 896 } }
  },
  FIGMA_API: "https://api.figma.com/v1/",
  DEFAULT_FIGMA_CONFIG: {
    "depth": 2,
    "figma_config": [
      {
        "figma_file_token": "token_for_first_figma_file",
        "figma_ids": [
          "id1",
          "id2"
        ]
      }
    ]
  }
};

// src/lib/schemaValidation.ts
var ajv = new Ajv__default.default({ allErrors: true });
ajv.addFormat("web-url", {
  type: "string",
  validate: (url) => {
    try {
      new URL(url.trim());
      return true;
    } catch (error) {
      return false;
    }
  }
});
addErrors__default.default(ajv);
var ConfigSchema = {
  type: "object",
  properties: {
    web: {
      type: "object",
      properties: {
        browsers: {
          type: "array",
          items: { type: "string", enum: [constants_default.CHROME, constants_default.FIREFOX, constants_default.SAFARI, constants_default.EDGE] },
          uniqueItems: true,
          maxItems: 4,
          errorMessage: `Invalid config; allowed browsers - ${constants_default.CHROME}, ${constants_default.FIREFOX}, ${constants_default.SAFARI}, ${constants_default.EDGE}`
        },
        viewports: {
          type: "array",
          items: {
            type: "array",
            oneOf: [
              {
                items: [{ type: "number", minimum: 320, maximum: 7680 }],
                minItems: 1,
                maxItems: 1
              },
              {
                items: [
                  { type: "number", minimum: 320, maximum: 7680 },
                  { type: "number", minimum: 320, maximum: 7680 }
                ],
                minItems: 2,
                maxItems: 2
              }
            ],
            errorMessage: "Invalid config; width/height must be >= 320 and <= 7680"
          },
          uniqueItems: true,
          maxItems: 5,
          errorMessage: "Invalid config; max unique viewports allowed - 5"
        }
      },
      required: ["browsers", "viewports"],
      additionalProperties: false
    },
    mobile: {
      type: "object",
      properties: {
        devices: {
          type: "array",
          items: {
            type: "string",
            enum: Object.keys(constants_default.SUPPORTED_MOBILE_DEVICES),
            minLength: 1,
            errorMessage: {
              enum: "Invalid config; unsupported mobile devices",
              minLength: "Invalid config; mobile device cannot be empty"
            }
          },
          uniqueItems: true,
          maxItems: 20,
          errorMessage: {
            uniqueItems: "Invalid config; duplicate mobile devices",
            maxItems: "Invalid config; max mobile devices allowed - 20"
          }
        },
        fullPage: {
          type: "boolean",
          errorMessage: "Invalid config; fullPage must be true/false"
        },
        orientation: {
          type: "string",
          enum: [constants_default.MOBILE_ORIENTATION_PORTRAIT, constants_default.MOBILE_ORIENTATION_LANDSCAPE],
          errorMessage: `Invalid config; orientation must be ${constants_default.MOBILE_ORIENTATION_PORTRAIT}/${constants_default.MOBILE_ORIENTATION_LANDSCAPE}`
        }
      },
      required: ["devices"],
      additionalProperties: false
    },
    waitForPageRender: {
      type: "number",
      minimum: 0,
      maximum: 3e5,
      errorMessage: "Invalid config; waitForPageRender must be > 0 and <= 300000"
    },
    waitForTimeout: {
      type: "number",
      minimum: 0,
      maximum: 3e4,
      errorMessage: "Invalid config; waitForTimeout must be > 0 and <= 30000"
    },
    enableJavaScript: {
      type: "boolean",
      errorMessage: "Invalid config; enableJavaScript must be true/false"
    },
    cliEnableJavaScript: {
      type: "boolean",
      errorMessage: "Invalid config; cliEnableJavaScript must be true/false"
    },
    scrollTime: {
      type: "number",
      minimum: 1,
      maximum: 1e3,
      errorMessage: "Invalid config; scrollTime must be > 1 and <= 1000"
    },
    allowedHostnames: {
      type: "array",
      items: {
        type: "string",
        minLength: 1,
        errorMessage: {
          minLength: "Invalid config; allowed hostname cannot be empty"
        }
      },
      uniqueItems: true,
      errorMessage: {
        uniqueItems: "Invalid config; duplicates in allowedHostnames"
      }
    },
    basicAuthorization: {
      type: "object",
      properties: {
        username: {
          type: "string",
          errorMessage: "Invalid config; username is mandatory"
        },
        password: {
          type: "string",
          errorMessage: "Invalid config; password is mandatory"
        }
      }
    }
  },
  anyOf: [
    { required: ["web"] },
    { required: ["mobile"] }
  ],
  additionalProperties: false
};
var WebStaticConfigSchema = {
  type: "array",
  items: {
    type: "object",
    properties: {
      name: {
        type: "string",
        minLength: 1,
        errorMessage: "name is mandatory and cannot be empty"
      },
      url: {
        type: "string",
        format: "web-url",
        errorMessage: "url is mandatory and must be a valid web URL"
      },
      waitForTimeout: {
        type: "number",
        nullable: true,
        minimum: 0,
        maximum: 3e4,
        errorMessage: "waitForTimeout must be > 0 and <= 30000"
      }
    },
    required: ["name", "url"],
    additionalProperties: false
  },
  uniqueItems: true
};
var SnapshotSchema = {
  type: "object",
  properties: {
    name: {
      type: "string",
      minLength: 1,
      errorMessage: "Invalid snapshot; name is mandatory and cannot be empty"
    },
    url: {
      type: "string",
      format: "web-url",
      errorMessage: "Invalid snapshot; url is mandatory and must be a valid web URL"
    },
    dom: {
      type: "object"
    },
    options: {
      type: "object",
      properties: {
        element: {
          type: "object",
          properties: {
            id: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element id cannot be empty or have semicolon"
            },
            class: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element class cannot be empty or have semicolon"
            },
            cssSelector: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element cssSelector cannot be empty or have semicolon"
            },
            xpath: {
              type: "string",
              errorMessage: "Invalid snapshot options; element xpath cannot be empty"
            }
          }
        },
        ignoreDOM: {
          type: "object",
          properties: {
            id: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM id cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM id array must have unique items"
            },
            class: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM class cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM class array must have unique items"
            },
            cssSelector: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM cssSelector cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM cssSelector array must have unique items"
            },
            xpath: {
              type: "array",
              items: { type: "string", minLength: 1 },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM xpath array must have unique and non-empty items"
            }
          }
        },
        selectDOM: {
          type: "object",
          properties: {
            id: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM id cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM id array must have unique items"
            },
            class: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM class cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM class array must have unique items"
            },
            cssSelector: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM cssSelector cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM cssSelector array must have unique items"
            },
            xpath: {
              type: "array",
              items: { type: "string", minLength: 1 },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM xpath array must have unique and non-empty items"
            }
          }
        }
      },
      additionalProperties: false
    }
  },
  required: ["name", "url", "dom"],
  additionalProperties: false,
  errorMessage: "Invalid snapshot"
};
var FigmaDesignConfigSchema = {
  type: "object",
  properties: {
    depth: {
      type: "integer",
      minimum: 2,
      errorMessage: "Depth must be an integer and greater than 1"
    },
    figma_config: {
      type: "array",
      items: {
        type: "object",
        properties: {
          figma_file_token: {
            type: "string",
            minLength: 1,
            errorMessage: "figma_file_token is mandatory and cannot be empty"
          },
          figma_ids: {
            type: "array",
            items: {
              type: "string",
              minLength: 1,
              errorMessage: "Each ID in figma_ids must be a non-empty string"
            },
            minItems: 1,
            uniqueItems: true,
            errorMessage: {
              type: "figma_ids must be an array of strings",
              minItems: "figma_ids cannot be empty",
              uniqueItems: "figma_ids must contain unique values"
            }
          }
        },
        required: ["figma_file_token"],
        additionalProperties: false
      },
      uniqueItems: true,
      errorMessage: {
        uniqueItems: "Each entry in the Figma design configuration must be unique"
      }
    }
  },
  required: ["figma_config"],
  additionalProperties: false
};
var validateConfig = ajv.compile(ConfigSchema);
var validateWebStaticConfig = ajv.compile(WebStaticConfigSchema);
var validateSnapshot = ajv.compile(SnapshotSchema);
var validateFigmaDesignConfig = ajv.compile(FigmaDesignConfigSchema);

// src/lib/server.ts
var server_default = (ctx) => __async(void 0, null, function* () {
  const server = fastify__default.default({
    logger: {
      level: "debug",
      stream: { write: (message) => {
        ctx.log.debug(message);
      } }
    },
    bodyLimit: 3e7
  });
  const opts = {};
  const SMARTUI_DOM = fs5.readFileSync(path2__default.default.resolve(__dirname, "dom-serializer.js"), "utf-8");
  server.get("/healthcheck", opts, (_, reply) => {
    reply.code(200).send({ cliVersion: ctx.cliVersion });
  });
  server.get("/domserializer", opts, (request, reply) => {
    reply.code(200).send({ data: { dom: SMARTUI_DOM } });
  });
  server.post("/snapshot", opts, (request, reply) => __async(void 0, null, function* () {
    var _a;
    let replyCode;
    let replyBody;
    try {
      let { snapshot, testType } = request.body;
      if (!validateSnapshot(snapshot))
        throw new Error(validateSnapshot.errors[0].message);
      ctx.testType = testType;
      (_a = ctx.snapshotQueue) == null ? void 0 : _a.enqueue(snapshot);
      replyCode = 200;
      replyBody = { data: { message: "success", warnings: [] } };
    } catch (error) {
      ctx.log.debug(`snapshot failed; ${error}`);
      replyCode = 500;
      replyBody = { error: { message: error.message } };
    }
    return reply.code(replyCode).send(replyBody);
  }));
  yield server.listen({ port: ctx.options.port });
  let { port } = server.addresses()[0];
  process.env.SMARTUI_SERVER_ADDRESS = `http://localhost:${port}`;
  process.env.CYPRESS_SMARTUI_SERVER_ADDRESS = `http://localhost:${port}`;
  return server;
});

// src/lib/env.ts
var env_default = () => {
  const {
    PROJECT_TOKEN = "",
    SMARTUI_CLIENT_API_URL = "https://api.lambdatest.com/visualui/1.0",
    LT_SDK_DEBUG,
    SMARTUI_GIT_INFO_FILEPATH,
    HTTP_PROXY,
    HTTPS_PROXY,
    GITHUB_ACTIONS,
    FIGMA_TOKEN,
    LT_USERNAME,
    LT_ACCESS_KEY,
    BASELINE_BRANCH,
    CURRENT_BRANCH
  } = process.env;
  return {
    PROJECT_TOKEN,
    SMARTUI_CLIENT_API_URL,
    LT_SDK_DEBUG,
    SMARTUI_GIT_INFO_FILEPATH,
    HTTP_PROXY,
    HTTPS_PROXY,
    GITHUB_ACTIONS,
    FIGMA_TOKEN,
    LT_USERNAME,
    LT_ACCESS_KEY,
    BASELINE_BRANCH,
    CURRENT_BRANCH
  };
};
var logContext = {};
function updateLogContext(newContext) {
  logContext = __spreadValues(__spreadValues({}, logContext), newContext);
}
var logLevel = () => {
  let env = env_default();
  return env.LT_SDK_DEBUG === "true" ? "debug" : "info";
};
var logger = winston.createLogger({
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf((info) => {
      let contextString = Object.values(logContext).join(" | ");
      let message = typeof info.message === "object" ? JSON.stringify(info.message).trim() : info.message.trim();
      switch (info.level) {
        case "warn":
          message = chalk7__default.default.yellow(message);
          break;
      }
      return info.level === "info" ? message : `[${contextString}:${info.level}] ` + message;
    })
  ),
  transports: [
    new winston.transports.Console({
      level: logLevel()
    }),
    new winston.transports.File({
      level: "debug",
      filename: constants_default.LOG_FILE_PATH
    })
  ]
});
var logger_default = logger;

// src/tasks/startServer.ts
var startServer_default = (ctx) => {
  return {
    title: `Setting up SmartUI server`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      var _a;
      updateLogContext({ task: "startServer" });
      try {
        ctx2.server = yield server_default(ctx2);
        task.output = chalk7__default.default.gray(`listening on port ${(_a = ctx2.server.addresses()[0]) == null ? void 0 : _a.port}`);
        task.title = "SmartUI started";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk7__default.default.gray(error.message);
        throw new Error("SmartUI server setup failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var auth_default = (ctx) => {
  return {
    title: `Authenticating with SmartUI`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "auth" });
      try {
        yield ctx2.client.auth(ctx2.log);
        task.output = chalk7__default.default.gray(`using project token '******#${ctx2.env.PROJECT_TOKEN.split("#").pop()}'`);
        task.title = "Authenticated with SmartUI";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk7__default.default.gray(error.message);
        throw new Error("Authentication failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};

// package.json
var version = "4.0.4";
var package_default = {
  name: "@lambdatest/smartui-cli",
  version,
  description: "A command line interface (CLI) to run SmartUI tests on LambdaTest",
  files: [
    "dist/**/*"
  ],
  scripts: {
    build: "tsup",
    release: "pnpm run build && pnpm publish --access public --no-git-checks"
  },
  bin: {
    smartui: "./dist/index.cjs"
  },
  type: "module",
  keywords: [
    "lambdatest",
    "smartui",
    "cli"
  ],
  author: "LambdaTest <keys@lambdatest.com>",
  license: "MIT",
  dependencies: {
    "@playwright/browser-chromium": "^1.45.3",
    "@playwright/browser-firefox": "^1.45.3",
    "@playwright/browser-webkit": "^1.45.3",
    "@playwright/test": "^1.45.3",
    "@types/cross-spawn": "^6.0.4",
    "@types/node": "^20.8.9",
    "@types/which": "^3.0.2",
    ajv: "^8.12.0",
    "ajv-errors": "^3.0.0",
    axios: "^1.6.0",
    chalk: "^4.1.2",
    commander: "^11.1.0",
    "cross-spawn": "^7.0.3",
    fastify: "^4.24.3",
    "form-data": "^4.0.0",
    listr2: "^7.0.1",
    sharp: "^0.33.4",
    tsup: "^7.2.0",
    which: "^4.0.0",
    winston: "^3.10.0"
  },
  devDependencies: {
    typescript: "^5.3.2"
  }
};
var httpClient = class {
  constructor({ SMARTUI_CLIENT_API_URL, PROJECT_TOKEN }) {
    this.axiosInstance = axios__default.default.create({
      baseURL: SMARTUI_CLIENT_API_URL,
      headers: { "projectToken": PROJECT_TOKEN }
    });
  }
  request(config, log2) {
    return __async(this, null, function* () {
      log2.debug(`http request: ${config.method} ${config.url}`);
      return this.axiosInstance.request(config).then((resp) => {
        log2.debug(`http response: ${JSON.stringify({
          status: resp.status,
          headers: resp.headers,
          body: resp.data
        })}`);
        return resp.data;
      }).catch((error) => {
        var _a;
        if (error.response) {
          log2.debug(`http response: ${JSON.stringify({
            status: error.response.status,
            headers: error.response.headers,
            body: error.response.data
          })}`);
          throw new Error(((_a = error.response.data.error) == null ? void 0 : _a.message) || error.response.data.message);
        }
        if (error.request) {
          log2.debug(`http request failed: ${error.toJSON()}`);
          throw new Error(error.toJSON().message);
        }
        log2.debug(`http request failed: ${error.message}`);
        throw new Error(error.message);
      });
    });
  }
  auth(log2) {
    return this.request({
      url: "/token/verify",
      method: "GET"
    }, log2);
  }
  createBuild(git, config, log2) {
    return this.request({
      url: "/build",
      method: "POST",
      data: {
        git,
        config
      }
    }, log2);
  }
  finalizeBuild(buildId, totalSnapshots, log2) {
    let params = { buildId };
    if (totalSnapshots > -1)
      params.totalSnapshots = totalSnapshots;
    return this.request({
      url: "/build",
      method: "DELETE",
      params
    }, log2);
  }
  uploadSnapshot(ctx, snapshot) {
    return this.request({
      url: `/builds/${ctx.build.id}/snapshot`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: {
        snapshot,
        test: {
          type: ctx.testType,
          source: "cli"
        }
      }
    }, ctx.log);
  }
  uploadScreenshot({ id: buildId, name: buildName, baseline }, ssPath, ssName, browserName, viewport, log2) {
    browserName = browserName === constants_default.SAFARI ? constants_default.WEBKIT : browserName;
    const file = fs5__default.default.readFileSync(ssPath);
    const form = new FormData__default.default();
    form.append("screenshot", file, { filename: `${ssName}.png`, contentType: "image/png" });
    form.append("browser", browserName);
    form.append("viewport", viewport);
    form.append("buildId", buildId);
    form.append("buildName", buildName);
    form.append("screenshotName", ssName);
    form.append("baseline", baseline.toString());
    return this.axiosInstance.request({
      url: `/screenshot`,
      method: "POST",
      headers: form.getHeaders(),
      data: form
    }).then(() => {
      log2.debug(`${ssName} for ${browserName} ${viewport} uploaded successfully`);
    }).catch((error) => {
      if (error.response) {
        throw new Error(error.response.data.error.message);
      }
      if (error.request) {
        throw new Error(error.toJSON().message);
      }
      throw new Error(error.message);
    });
  }
  checkUpdate(log2) {
    return this.request({
      url: `/packageinfo`,
      method: "GET",
      headers: { "Content-Type": "application/json" },
      params: {
        packageName: package_default.name,
        packageVersion: package_default.version
      }
    }, log2);
  }
  getFigmaFilesAndImages(figmaFileToken, figmaToken, queryParams, authToken, depth, markBaseline, buildName, log2) {
    const requestBody = {
      figma_file_token: figmaFileToken,
      figma_token: figmaToken,
      query_params: queryParams,
      auth: authToken,
      depth,
      mark_base_line: markBaseline,
      build_name: buildName
    };
    return this.request({
      url: "/uploadfigma",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      data: JSON.stringify(requestBody)
    }, log2);
  }
  getS3PreSignedURL(ctx) {
    return this.request({
      url: `/loguploadurl`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: {
        buildId: ctx.build.id
      }
    }, ctx.log);
  }
  uploadLogs(ctx, uploadURL) {
    const fileStream = fs5__default.default.createReadStream(constants_default.LOG_FILE_PATH);
    const { size } = fs5__default.default.statSync(constants_default.LOG_FILE_PATH);
    return this.request({
      url: uploadURL,
      method: "PUT",
      headers: {
        "Content-Type": "text/plain",
        "Content-Length": size
      },
      data: fileStream,
      maxBodyLength: Infinity,
      // prevent axios from limiting the body size
      maxContentLength: Infinity
      // prevent axios from limiting the content size
    }, ctx.log);
  }
};
var ctx_default = (options) => {
  var _a, _b, _c;
  let env = env_default();
  let webConfig;
  let mobileConfig;
  let basicAuthObj;
  let config = constants_default.DEFAULT_CONFIG;
  let port;
  let resolutionOff;
  let extensionFiles;
  let ignoreStripExtension;
  let ignoreFilePattern;
  try {
    if (options.config) {
      config = JSON.parse(fs5__default.default.readFileSync(options.config, "utf-8"));
      if ((_a = config.web) == null ? void 0 : _a.resolutions) {
        config.web.viewports = config.web.resolutions;
        delete config.web.resolutions;
      }
      if (!validateConfig(config)) {
        throw new Error(validateConfig.errors[0].message);
      }
    }
    port = parseInt(options.port || "49152", 10);
    if (isNaN(port) || port < 1 || port > 65535) {
      throw new Error("Invalid port number. Port number must be an integer between 1 and 65535.");
    }
    resolutionOff = options.ignoreResolutions || false;
    extensionFiles = options.files || ["png", "jpeg", "jpg"];
    ignoreStripExtension = options.removeExtensions || false;
    ignoreFilePattern = options.ignoreDir || [];
  } catch (error) {
    console.log(`[smartui] Error: ${error.message}`);
    process.exit();
  }
  if (config.web) {
    webConfig = { browsers: config.web.browsers, viewports: [] };
    for (let viewport of (_b = config.web) == null ? void 0 : _b.viewports)
      webConfig.viewports.push({ width: viewport[0], height: viewport[1] || 0 });
  }
  if (config.mobile) {
    mobileConfig = {
      devices: config.mobile.devices,
      fullPage: (_c = config.mobile.fullPage) != null ? _c : true,
      orientation: config.mobile.orientation || constants_default.MOBILE_ORIENTATION_PORTRAIT
    };
  }
  if (config.basicAuthorization) {
    basicAuthObj = config.basicAuthorization;
  }
  return {
    env,
    log: logger_default,
    client: new httpClient(env),
    config: {
      web: webConfig,
      mobile: mobileConfig,
      waitForPageRender: config.waitForPageRender || 0,
      waitForTimeout: config.waitForTimeout || 0,
      enableJavaScript: config.enableJavaScript || false,
      cliEnableJavaScript: config.cliEnableJavaScript || true,
      scrollTime: config.scrollTime || constants_default.DEFAULT_SCROLL_TIME,
      allowedHostnames: config.allowedHostnames || [],
      basicAuthorization: basicAuthObj
    },
    uploadFilePath: "",
    webStaticConfig: [],
    git: {
      branch: "",
      commitId: "",
      commitAuthor: "",
      commitMessage: "",
      githubURL: ""
    },
    build: {
      id: "",
      name: "",
      baseline: false,
      url: ""
    },
    args: {},
    options: {
      parallel: options.parallel ? true : false,
      markBaseline: options.markBaseline ? true : false,
      buildName: options.buildName || "",
      port,
      ignoreResolutions: resolutionOff,
      fileExtension: extensionFiles,
      stripExtension: ignoreStripExtension,
      ignorePattern: ignoreFilePattern
    },
    cliVersion: version,
    totalSnapshots: -1
  };
};
function executeCommand(command5) {
  let dst = process.cwd();
  try {
    return child_process.execSync(command5, {
      cwd: dst,
      stdio: ["ignore"],
      encoding: "utf-8"
    });
  } catch (error) {
    throw new Error(error.message);
  }
}
function isGitRepo() {
  try {
    executeCommand("git status");
    return true;
  } catch (error) {
    return false;
  }
}
var git_default = (ctx) => {
  if (ctx.env.SMARTUI_GIT_INFO_FILEPATH) {
    let gitInfo = JSON.parse(fs5__default.default.readFileSync(ctx.env.SMARTUI_GIT_INFO_FILEPATH, "utf-8"));
    return {
      branch: ctx.env.CURRENT_BRANCH || gitInfo.branch || "",
      commitId: gitInfo.commit_id.slice(0, 6) || "",
      commitMessage: gitInfo.commit_body || "",
      commitAuthor: gitInfo.commit_author || "",
      githubURL: ctx.env.GITHUB_ACTIONS ? `${constants_default.GITHUB_API_HOST}/repos/${process.env.GITHUB_REPOSITORY}/statuses/${gitInfo.commit_id}` : "",
      baselineBranch: ctx.env.BASELINE_BRANCH || ""
    };
  } else {
    const splitCharacter = "<##>";
    const prettyFormat = ["%h", "%H", "%s", "%f", "%b", "%at", "%ct", "%an", "%ae", "%cn", "%ce", "%N", ""];
    const command5 = 'git log -1 --pretty=format:"' + prettyFormat.join(splitCharacter) + '" && git rev-parse --abbrev-ref HEAD && git tag --contains HEAD';
    let res = executeCommand(command5).split(splitCharacter);
    var branchAndTags = res[res.length - 1].split("\n").filter((n) => n);
    var branch = ctx.env.CURRENT_BRANCH || branchAndTags[0];
    branchAndTags.slice(1);
    return {
      branch: branch || "",
      commitId: res[0] || "",
      commitMessage: res[2] || "",
      commitAuthor: res[7] || "",
      githubURL: ctx.env.GITHUB_ACTIONS ? `${constants_default.GITHUB_API_HOST}/repos/${process.env.GITHUB_REPOSITORY}/statuses/${res[1]}` : "",
      baselineBranch: ctx.env.BASELINE_BRANCH || ""
    };
  }
};
var getGitInfo_default = (ctx) => {
  return {
    title: `Fetching git repo details`,
    skip: (ctx2) => {
      return !isGitRepo() && !ctx2.env.SMARTUI_GIT_INFO_FILEPATH ? "[SKIPPED] Fetching git repo details; not a git repo" : "";
    },
    task: (ctx2, task) => __async(void 0, null, function* () {
      if (ctx2.env.CURRENT_BRANCH && ctx2.env.CURRENT_BRANCH.trim() === "") {
        throw new Error("Error: The environment variable CURRENT_BRANCH cannot be empty.");
      }
      try {
        ctx2.git = git_default(ctx2);
        task.output = chalk7__default.default.gray(`branch: ${ctx2.git.branch}, commit: ${ctx2.git.commitId}, author: ${ctx2.git.commitAuthor}`);
        task.title = "Fetched git information";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk7__default.default.gray(`${error.message}`);
        throw new Error("Error fetching git repo details");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var createBuild_default = (ctx) => {
  return {
    title: `Creating SmartUI build`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "createBuild" });
      try {
        let resp = yield ctx2.client.createBuild(ctx2.git, ctx2.config, ctx2.log);
        ctx2.build = {
          id: resp.data.buildId,
          name: resp.data.buildName,
          url: resp.data.buildURL,
          baseline: resp.data.baseline
        };
        task.output = chalk7__default.default.gray(`build id: ${resp.data.buildId}`);
        task.title = "SmartUI build created";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk7__default.default.gray(error.message);
        throw new Error("SmartUI build creation failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var exec_default = (ctx) => {
  var _a;
  return {
    title: `Executing '${(_a = ctx.args.execCommand) == null ? void 0 : _a.join(" ")}'`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "exec" });
      return new Promise((resolve, reject) => {
        var _a2, _b, _c;
        const childProcess = spawn__default.default(ctx2.args.execCommand[0], (_a2 = ctx2.args.execCommand) == null ? void 0 : _a2.slice(1));
        let totalOutput = "";
        const output = listr2.createWritable((chunk) => {
          totalOutput += chunk;
          task.output = chalk7__default.default.gray(totalOutput);
        });
        (_b = childProcess.stdout) == null ? void 0 : _b.pipe(output);
        (_c = childProcess.stderr) == null ? void 0 : _c.pipe(output);
        childProcess.on("error", (error) => {
          var _a3;
          task.output = chalk7__default.default.gray(`error: ${error.message}`);
          throw new Error(`Execution of '${(_a3 = ctx2.args.execCommand) == null ? void 0 : _a3.join(" ")}' failed`);
        });
        childProcess.on("close", (code, signal) => __async(void 0, null, function* () {
          var _a3;
          if (code !== null) {
            task.title = `Execution of '${(_a3 = ctx2.args.execCommand) == null ? void 0 : _a3.join(" ")}' completed; exited with code ${code}`;
          } else if (signal !== null) {
            throw new Error(`Child process killed with signal ${signal}`);
          }
          resolve();
        }));
      });
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};
var processSnapshot_default = (ctx) => {
  return {
    title: `Processing snapshots`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      var _a;
      try {
        yield new Promise((resolve) => {
          let output2 = "";
          const intervalId = setInterval(() => {
            var _a2, _b, _c;
            if (((_a2 = ctx2.snapshotQueue) == null ? void 0 : _a2.isEmpty()) && !((_b = ctx2.snapshotQueue) == null ? void 0 : _b.isProcessing())) {
              clearInterval(intervalId);
              resolve();
            } else {
              task.title = `Processing snapshot ${(_c = ctx2.snapshotQueue) == null ? void 0 : _c.getProcessingSnapshot()}`;
            }
          }, 500);
        });
        let output = "";
        for (let snapshot of (_a = ctx2.snapshotQueue) == null ? void 0 : _a.getProcessedSnapshots()) {
          if (snapshot.error)
            output += `${chalk7__default.default.red("\u2717")} ${chalk7__default.default.gray(`${snapshot.name}
[error] ${snapshot.error}`)}
`;
          else
            output += `${chalk7__default.default.green("\u2713")} ${chalk7__default.default.gray(snapshot.name)}
${snapshot.warnings.length ? chalk7__default.default.gray(`[warning] ${snapshot.warnings.join("\n[warning] ")}
`) : ""}`;
        }
        task.output = output;
        task.title = "Processed snapshots";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk7__default.default.gray(error.message);
        throw new Error("Processing of snapshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var finalizeBuild_default = (ctx) => {
  return {
    title: `Finalizing build`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      var _a, _b;
      updateLogContext({ task: "finalizeBuild" });
      try {
        yield ctx2.client.finalizeBuild(ctx2.build.id, ctx2.totalSnapshots, ctx2.log);
        task.output = chalk7__default.default.gray(`build url: ${ctx2.build.url}`);
        task.title = "Finalized build";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk7__default.default.gray(error.message);
        throw new Error("Finalize build failed");
      }
      try {
        yield (_a = ctx2.browser) == null ? void 0 : _a.close();
        ctx2.log.debug(`Closed browser`);
        yield (_b = ctx2.server) == null ? void 0 : _b.close();
        ctx2.log.debug(`Closed server`);
        let resp = yield ctx2.client.getS3PreSignedURL(ctx2);
        yield ctx2.client.uploadLogs(ctx2, resp.data.url);
        fs5.unlinkSync(constants_default.LOG_FILE_PATH);
      } catch (error) {
        ctx2.log.debug(error);
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
function delDir(dir) {
  if (fs5__default.default.existsSync(dir)) {
    fs5__default.default.rmSync(dir, { recursive: true });
  }
}
function scrollToBottomAndBackToTop({
  frequency = 100,
  timing = 8,
  remoteWindow = window
} = {}) {
  return new Promise((resolve) => {
    let scrolls = 1;
    let scrollLength = remoteWindow.document.body.scrollHeight / frequency;
    (function scroll() {
      let scrollBy = scrollLength * scrolls;
      remoteWindow.setTimeout(() => {
        remoteWindow.scrollTo(0, scrollBy);
        if (scrolls < frequency) {
          scrolls += 1;
          scroll();
        }
        if (scrolls === frequency) {
          remoteWindow.setTimeout(() => {
            remoteWindow.scrollTo(0, 0);
            resolve();
          }, timing);
        }
      }, timing);
    })();
  });
}
function launchBrowsers(ctx) {
  return __async(this, null, function* () {
    let browsers = {};
    let launchOptions = { headless: true };
    if (ctx.config.web) {
      for (const browser of ctx.config.web.browsers) {
        switch (browser) {
          case constants_default.CHROME:
            browsers[constants_default.CHROME] = yield test.chromium.launch(launchOptions);
            break;
          case constants_default.SAFARI:
            browsers[constants_default.SAFARI] = yield test.webkit.launch(launchOptions);
            break;
          case constants_default.FIREFOX:
            browsers[constants_default.FIREFOX] = yield test.firefox.launch(launchOptions);
            break;
          case constants_default.EDGE:
            browsers[constants_default.EDGE] = yield test.chromium.launch(__spreadValues({ channel: constants_default.EDGE_CHANNEL }, launchOptions));
            break;
        }
      }
    }
    if (ctx.config.mobile) {
      for (const device of ctx.config.mobile.devices) {
        if (constants_default.SUPPORTED_MOBILE_DEVICES[device].os === "android" && !browsers[constants_default.CHROME])
          browsers[constants_default.CHROME] = yield test.chromium.launch(launchOptions);
        else if (constants_default.SUPPORTED_MOBILE_DEVICES[device].os === "ios" && !browsers[constants_default.SAFARI])
          browsers[constants_default.SAFARI] = yield test.webkit.launch(launchOptions);
      }
    }
    return browsers;
  });
}
function closeBrowsers(browsers) {
  return __async(this, null, function* () {
    var _a;
    for (const browserName of Object.keys(browsers))
      yield (_a = browsers[browserName]) == null ? void 0 : _a.close();
  });
}
function getWebRenderViewports(ctx) {
  let webRenderViewports = [];
  if (ctx.config.web) {
    for (const viewport of ctx.config.web.viewports) {
      webRenderViewports.push({
        viewport,
        viewportString: `${viewport.width}${viewport.height ? "x" + viewport.height : ""}`,
        fullPage: viewport.height ? false : true,
        device: false
      });
    }
  }
  return webRenderViewports;
}
function getMobileRenderViewports(ctx) {
  var _a;
  let mobileRenderViewports = {};
  mobileRenderViewports[constants_default.MOBILE_OS_IOS] = [];
  mobileRenderViewports[constants_default.MOBILE_OS_ANDROID] = [];
  if (ctx.config.mobile) {
    for (const device of ctx.config.mobile.devices) {
      let os = constants_default.SUPPORTED_MOBILE_DEVICES[device].os;
      let { width, height } = constants_default.SUPPORTED_MOBILE_DEVICES[device].viewport;
      let portrait = ctx.config.mobile.orientation === constants_default.MOBILE_ORIENTATION_PORTRAIT ? true : false;
      (_a = mobileRenderViewports[os]) == null ? void 0 : _a.push({
        viewport: { width: portrait ? width : height, height: portrait ? height : width },
        viewportString: `${device} (${ctx.config.mobile.orientation})`,
        fullPage: ctx.config.mobile.fullPage,
        device: true,
        os
      });
    }
  }
  return mobileRenderViewports;
}
function getRenderViewports(ctx) {
  let mobileRenderViewports = getMobileRenderViewports(ctx);
  let webRenderViewports = getWebRenderViewports(ctx);
  return [
    ...webRenderViewports,
    ...mobileRenderViewports[constants_default.MOBILE_OS_IOS],
    ...mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]
  ];
}
var MAX_RESOURCE_SIZE = 15 * 1024 ** 2;
var ALLOWED_RESOURCES = ["document", "stylesheet", "image", "media", "font", "other"];
var ALLOWED_STATUSES = [200, 201];
var REQUEST_TIMEOUT = 1e4;
var MIN_VIEWPORT_HEIGHT = 1080;
var Queue = class {
  constructor(ctx) {
    this.snapshots = [];
    this.processedSnapshots = [];
    this.processing = false;
    this.processingSnapshot = "";
    this.ctx = ctx;
  }
  enqueue(item) {
    this.snapshots.push(item);
    if (!this.processing) {
      this.processing = true;
      this.processNext();
    }
  }
  processNext() {
    return __async(this, null, function* () {
      if (!this.isEmpty()) {
        const snapshot = this.snapshots.shift();
        try {
          this.processingSnapshot = snapshot == null ? void 0 : snapshot.name;
          let { processedSnapshot, warnings } = yield processSnapshot(snapshot, this.ctx);
          yield this.ctx.client.uploadSnapshot(this.ctx, processedSnapshot);
          this.ctx.totalSnapshots++;
          this.processedSnapshots.push({ name: snapshot.name, warnings });
        } catch (error) {
          this.ctx.log.debug(`snapshot failed; ${error}`);
          this.processedSnapshots.push({ name: snapshot.name, error: error.message });
        }
        if (this.ctx.browser) {
          for (let context of this.ctx.browser.contexts()) {
            for (let page of context.pages()) {
              yield page.close();
              this.ctx.log.debug(`Closed browser page for snapshot ${snapshot.name}`);
            }
            yield context.close();
            this.ctx.log.debug(`Closed browser context for snapshot ${snapshot.name}`);
          }
        }
        this.processNext();
      } else {
        this.processing = false;
      }
    });
  }
  isProcessing() {
    return this.processing;
  }
  getProcessingSnapshot() {
    return this.processingSnapshot;
  }
  getProcessedSnapshots() {
    return this.processedSnapshots;
  }
  isEmpty() {
    return this.snapshots.length ? false : true;
  }
};
function processSnapshot(snapshot, ctx) {
  return __async(this, null, function* () {
    var _a;
    updateLogContext({ task: "discovery" });
    ctx.log.debug(`Processing snapshot ${snapshot.name} ${snapshot.url}`);
    let launchOptions = { headless: true };
    let contextOptions = {
      javaScriptEnabled: ctx.config.cliEnableJavaScript,
      userAgent: constants_default.CHROME_USER_AGENT
    };
    if (!((_a = ctx.browser) == null ? void 0 : _a.isConnected())) {
      if (ctx.env.HTTP_PROXY || ctx.env.HTTPS_PROXY)
        launchOptions.proxy = { server: ctx.env.HTTP_PROXY || ctx.env.HTTPS_PROXY };
      ctx.browser = yield test.chromium.launch(launchOptions);
      ctx.log.debug(`Chromium launched with options ${JSON.stringify(launchOptions)}`);
    }
    const context = yield ctx.browser.newContext(contextOptions);
    ctx.log.debug(`Browser context created with options ${JSON.stringify(contextOptions)}`);
    if (snapshot.dom.cookies) {
      const domainName = new URL(snapshot.url).hostname;
      ctx.log.debug(`Setting cookies for domain: ${domainName}`);
      const cookieArray = snapshot.dom.cookies.split("; ").map((cookie) => {
        if (!cookie)
          return null;
        const [name, value] = cookie.split("=");
        if (!name || !value)
          return null;
        return {
          name: name.trim(),
          value: value.trim(),
          domain: domainName,
          path: "/"
        };
      }).filter(Boolean);
      if (cookieArray.length > 0) {
        yield context.addCookies(cookieArray);
      } else {
        ctx.log.debug("No valid cookies to add");
      }
    }
    const page = yield context.newPage();
    let cache = {};
    if (snapshot.dom.resources.length) {
      for (let resource of snapshot.dom.resources) {
        let body = resource.mimetype == "text/css" ? Buffer.from(resource.content).toString("base64") : resource.content;
        cache[resource.url] = {
          body,
          type: resource.mimetype
        };
      }
    }
    yield page.route("**/*", (route, request) => __async(this, null, function* () {
      const requestUrl = request.url();
      const requestHostname = new URL(requestUrl).hostname;
      let requestOptions = { timeout: REQUEST_TIMEOUT };
      try {
        if (/\.(mp3|mp4|wav|ogg|webm)$/i.test(request.url())) {
          throw new Error("resource type mp3/mp4/wav/ogg/webm");
        }
        ctx.config.allowedHostnames.push(new URL(snapshot.url).hostname);
        if (ctx.config.enableJavaScript)
          ALLOWED_RESOURCES.push("script");
        if (ctx.config.basicAuthorization) {
          ctx.log.debug(`Adding basic authorization to the headers for root url`);
          let token = Buffer.from(`${ctx.config.basicAuthorization.username}:${ctx.config.basicAuthorization.password}`).toString("base64");
          requestOptions.headers = __spreadProps(__spreadValues({}, request.headers()), {
            Authorization: `Basic ${token}`
          });
        }
        let response, body;
        if (requestUrl === snapshot.url) {
          response = {
            status: () => 200,
            headers: () => ({ "content-type": "text/html" })
          };
          body = snapshot.dom.html;
        } else if (cache[requestUrl]) {
          response = {
            status: () => 200,
            headers: () => ({ "content-type": cache[requestUrl].mimetype })
          };
          body = cache[requestUrl].body;
        } else {
          response = yield page.request.fetch(request, requestOptions);
          body = yield response.body();
        }
        if (!body) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping no response`);
        } else if (!body.length) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping empty response`);
        } else if (requestUrl === snapshot.url) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping root resource`);
        } else if (!ctx.config.allowedHostnames.includes(requestHostname)) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping remote resource`);
        } else if (cache[requestUrl]) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping already cached resource`);
        } else if (body.length > MAX_RESOURCE_SIZE) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping resource larger than 15MB`);
        } else if (!ALLOWED_STATUSES.includes(response.status())) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping disallowed status [${response.status()}]`);
        } else if (!ALLOWED_RESOURCES.includes(request.resourceType())) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping disallowed resource type [${request.resourceType()}]`);
        } else {
          ctx.log.debug(`Handling request ${requestUrl}
 - content-type ${response.headers()["content-type"]}`);
          cache[requestUrl] = {
            body: body.toString("base64"),
            type: response.headers()["content-type"]
          };
        }
        route.fulfill({
          status: response.status(),
          headers: response.headers(),
          body
        });
      } catch (error) {
        ctx.log.debug(`Handling request ${requestUrl}
 - aborted due to ${error.message}`);
        route.abort();
      }
    }));
    let options = snapshot.options;
    let optionWarnings = /* @__PURE__ */ new Set();
    let processedOptions = {};
    let selectors = [];
    let ignoreOrSelectDOM;
    let ignoreOrSelectBoxes;
    if (options && Object.keys(options).length) {
      ctx.log.debug(`Snapshot options: ${JSON.stringify(options)}`);
      const isNotAllEmpty = (obj) => {
        var _a2;
        for (let key in obj)
          if ((_a2 = obj[key]) == null ? void 0 : _a2.length)
            return true;
        return false;
      };
      if (options.element && Object.keys(options.element).length) {
        if (options.element.id)
          processedOptions.element = "#" + options.element.id;
        else if (options.element.class)
          processedOptions.element = "." + options.element.class;
        else if (options.element.cssSelector)
          processedOptions.element = options.element.cssSelector;
        else if (options.element.xpath)
          processedOptions.element = "xpath=" + options.element.xpath;
      } else if (options.ignoreDOM && Object.keys(options.ignoreDOM).length && isNotAllEmpty(options.ignoreDOM)) {
        processedOptions.ignoreBoxes = {};
        ignoreOrSelectDOM = "ignoreDOM";
        ignoreOrSelectBoxes = "ignoreBoxes";
      } else if (options.selectDOM && Object.keys(options.selectDOM).length && isNotAllEmpty(options.selectDOM)) {
        processedOptions.selectBoxes = {};
        ignoreOrSelectDOM = "selectDOM";
        ignoreOrSelectBoxes = "selectBoxes";
      }
      if (ignoreOrSelectDOM) {
        for (const [key, value] of Object.entries(options[ignoreOrSelectDOM])) {
          switch (key) {
            case "id":
              selectors.push(...value.map((e) => "#" + e));
              break;
            case "class":
              selectors.push(...value.map((e) => "." + e));
              break;
            case "xpath":
              selectors.push(...value.map((e) => "xpath=" + e));
              break;
            case "cssSelector":
              selectors.push(...value);
              break;
          }
        }
      }
    }
    let navigated = false;
    let previousDeviceType = null;
    let renderViewports = getRenderViewports(ctx);
    for (const { viewport, viewportString, fullPage, device } of renderViewports) {
      if (previousDeviceType !== null && previousDeviceType !== device) {
        navigated = false;
      }
      previousDeviceType = device;
      yield page.setViewportSize({ width: viewport.width, height: viewport.height || MIN_VIEWPORT_HEIGHT });
      ctx.log.debug(`Page resized to ${viewport.width}x${viewport.height || MIN_VIEWPORT_HEIGHT}`);
      if (!navigated) {
        try {
          yield page.goto(snapshot.url, { waitUntil: "domcontentloaded" });
          yield new Promise((r) => setTimeout(r, 1250));
          if (ctx.config.waitForTimeout)
            yield page.waitForTimeout(ctx.config.waitForTimeout);
          navigated = true;
          ctx.log.debug(`Navigated to ${snapshot.url}`);
        } catch (error) {
          ctx.log.debug(`Navigation to discovery page failed; ${error}`);
          throw new Error(error.message);
        }
      }
      if (ctx.config.cliEnableJavaScript && fullPage)
        yield page.evaluate(scrollToBottomAndBackToTop, { frequency: 100, timing: ctx.config.scrollTime });
      try {
        yield page.waitForLoadState("networkidle", { timeout: 5e3 });
        ctx.log.debug("Network idle 500ms");
      } catch (error) {
        ctx.log.debug(`Network idle failed due to ${error}`);
      }
      if (processedOptions.element) {
        let l = yield page.locator(processedOptions.element).all();
        if (l.length === 0) {
          throw new Error(`for snapshot ${snapshot.name} viewport ${viewportString}, no element found for selector ${processedOptions.element}`);
        } else if (l.length > 1) {
          throw new Error(`for snapshot ${snapshot.name} viewport ${viewportString}, multiple elements found for selector ${processedOptions.element}`);
        }
      } else if (selectors.length) {
        let locators = [];
        if (!Array.isArray(processedOptions[ignoreOrSelectBoxes][viewportString]))
          processedOptions[ignoreOrSelectBoxes][viewportString] = [];
        for (const selector of selectors) {
          let l = yield page.locator(selector).all();
          if (l.length === 0) {
            optionWarnings.add(`for snapshot ${snapshot.name} viewport ${viewportString}, no element found for selector ${selector}`);
            continue;
          }
          locators.push(...l);
        }
        for (const locator of locators) {
          let bb = yield locator.boundingBox();
          if (bb)
            processedOptions[ignoreOrSelectBoxes][viewportString].push({
              left: bb.x,
              top: bb.y,
              right: bb.x + bb.width,
              bottom: bb.y + bb.height
            });
        }
      }
    }
    return {
      processedSnapshot: {
        name: snapshot.name,
        url: snapshot.url,
        dom: Buffer.from(snapshot.dom.html).toString("base64"),
        resources: cache,
        options: processedOptions
      },
      warnings: [...optionWarnings, ...snapshot.dom.warnings]
    };
  });
}

// src/commander/exec.ts
var command = new commander.Command();
command.name("exec").description("Run test commands around SmartUI").argument("<command...>", "Command supplied for running tests").option("-P, --port <number>", "Port number for the server").action(function(execCommand, _, command5) {
  return __async(this, null, function* () {
    let ctx = ctx_default(command5.optsWithGlobals());
    if (!which__default.default.sync(execCommand[0], { nothrow: true })) {
      ctx.log.error(`Error: Command not found "${execCommand[0]}"`);
      return;
    }
    ctx.args.execCommand = execCommand;
    ctx.snapshotQueue = new Queue(ctx);
    ctx.totalSnapshots = 0;
    let tasks = new listr2.Listr(
      [
        auth_default(),
        startServer_default(),
        getGitInfo_default(),
        createBuild_default(),
        exec_default(ctx),
        processSnapshot_default(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      ctx.log.info("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
var exec_default2 = command;
function createConfig(filepath) {
  filepath = filepath || ".smartui.json";
  let filetype = path2__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: Config file must have .json extension");
    return;
  }
  if (fs5__default.default.existsSync(filepath)) {
    console.log(`Error: SmartUI Config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:create .smartui-config.json'`);
    return;
  }
  fs5__default.default.mkdirSync(path2__default.default.dirname(filepath), { recursive: true });
  fs5__default.default.writeFileSync(filepath, JSON.stringify(constants_default.DEFAULT_CONFIG, null, 2) + "\n");
  console.log(`Created SmartUI Config: ${filepath}`);
}
function createWebStaticConfig(filepath) {
  filepath = filepath || "url.json";
  let filetype = path2__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: Config file must have .json extension");
    return;
  }
  if (fs5__default.default.existsSync(filepath)) {
    console.log(`Error: web-static config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:create-web-static links.json'`);
    return;
  }
  fs5__default.default.mkdirSync(path2__default.default.dirname(filepath), { recursive: true });
  fs5__default.default.writeFileSync(filepath, JSON.stringify(constants_default.DEFAULT_WEB_STATIC_CONFIG, null, 2) + "\n");
  console.log(`Created web-static config: ${filepath}`);
}
function createFigmaConfig(filepath) {
  filepath = filepath || "designs.json";
  let filetype = path2__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: designs config file must have .json extension");
    return;
  }
  if (fs5__default.default.existsSync(filepath)) {
    console.log(`Error: designs config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:figma-config designs.json'`);
    return;
  }
  fs5__default.default.mkdirSync(path2__default.default.dirname(filepath), { recursive: true });
  fs5__default.default.writeFileSync(filepath, JSON.stringify(constants_default.DEFAULT_FIGMA_CONFIG, null, 2) + "\n");
  console.log(`Created designs config: ${filepath}`);
}

// src/commander/config.ts
var configWeb = new commander.Command();
var configStatic = new commander.Command();
var configFigma = new commander.Command();
configWeb.name("config:create").description("Create SmartUI config file").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createConfig(filepath);
  });
});
configStatic.name("config:create-web-static").description("Create Web Static config file").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createWebStaticConfig(filepath);
  });
});
configFigma.name("config:create-figma").description("Create figma designs config file").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createFigmaConfig(filepath);
  });
});
function captureScreenshotsForConfig(_0, _1, _2, _3, _4) {
  return __async(this, arguments, function* (ctx, browsers, { name, url, waitForTimeout }, browserName, renderViewports) {
    let pageOptions = { waitUntil: process.env.SMARTUI_PAGE_WAIT_UNTIL_EVENT || "load" };
    let ssId = name.toLowerCase().replace(/\s/g, "_");
    let context;
    let contextOptions = {};
    let page;
    if (browserName == constants_default.CHROME)
      contextOptions.userAgent = constants_default.CHROME_USER_AGENT;
    else if (browserName == constants_default.FIREFOX)
      contextOptions.userAgent = constants_default.FIREFOX_USER_AGENT;
    else if (browserName == constants_default.SAFARI)
      contextOptions.userAgent = constants_default.SAFARI_USER_AGENT;
    else if (browserName == constants_default.EDGE)
      contextOptions.userAgent = constants_default.EDGE_USER_AGENT;
    try {
      const browser = browsers[browserName];
      context = yield browser == null ? void 0 : browser.newContext(contextOptions);
      page = yield context == null ? void 0 : context.newPage();
      yield page == null ? void 0 : page.goto(url.trim(), pageOptions);
      for (let { viewport, viewportString, fullPage } of renderViewports) {
        let ssPath = `screenshots/${ssId}/${`${browserName}-${viewport.width}x${viewport.height}`}-${ssId}.png`;
        yield page == null ? void 0 : page.setViewportSize({ width: viewport.width, height: viewport.height || constants_default.MIN_VIEWPORT_HEIGHT });
        if (fullPage)
          yield page == null ? void 0 : page.evaluate(scrollToBottomAndBackToTop);
        yield page == null ? void 0 : page.waitForTimeout(waitForTimeout || 0);
        yield page == null ? void 0 : page.screenshot({ path: ssPath, fullPage });
        yield ctx.client.uploadScreenshot(ctx.build, ssPath, name, browserName, viewportString, ctx.log);
      }
    } catch (error) {
      throw new Error(`captureScreenshotsForConfig failed for browser ${browserName}; error: ${error}`);
    } finally {
      yield page == null ? void 0 : page.close();
      yield context == null ? void 0 : context.close();
    }
  });
}
function captureScreenshotsAsync(ctx, staticConfig, browsers) {
  return __async(this, null, function* () {
    let capturePromises = [];
    if (ctx.config.web) {
      for (let browserName of ctx.config.web.browsers) {
        let webRenderViewports = getWebRenderViewports(ctx);
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, browserName, webRenderViewports));
      }
    }
    if (ctx.config.mobile) {
      let mobileRenderViewports = getMobileRenderViewports(ctx);
      if (mobileRenderViewports[constants_default.MOBILE_OS_IOS].length) {
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.SAFARI, mobileRenderViewports[constants_default.MOBILE_OS_IOS]));
      }
      if (mobileRenderViewports[constants_default.MOBILE_OS_ANDROID].length) {
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.CHROME, mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]));
      }
    }
    return Promise.all(capturePromises);
  });
}
function captureScreenshotsSync(ctx, staticConfig, browsers) {
  return __async(this, null, function* () {
    if (ctx.config.web) {
      for (let browserName of ctx.config.web.browsers) {
        let webRenderViewports = getWebRenderViewports(ctx);
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, browserName, webRenderViewports);
      }
    }
    if (ctx.config.mobile) {
      let mobileRenderViewports = getMobileRenderViewports(ctx);
      if (mobileRenderViewports[constants_default.MOBILE_OS_IOS].length) {
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.SAFARI, mobileRenderViewports[constants_default.MOBILE_OS_IOS]);
      }
      if (mobileRenderViewports[constants_default.MOBILE_OS_ANDROID].length) {
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.CHROME, mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]);
      }
    }
  });
}
function captureScreenshots(ctx) {
  return __async(this, null, function* () {
    delDir("screenshots");
    let browsers = {};
    let capturedScreenshots = 0;
    let output = "";
    try {
      browsers = yield launchBrowsers(ctx);
    } catch (error) {
      yield closeBrowsers(browsers);
      ctx.log.debug(error);
      throw new Error(`Failed launching browsers`);
    }
    for (let staticConfig of ctx.webStaticConfig) {
      try {
        if (ctx.options.parallel)
          yield captureScreenshotsAsync(ctx, staticConfig, browsers);
        else
          yield captureScreenshotsSync(ctx, staticConfig, browsers);
        delDir(`screenshots/${staticConfig.name.toLowerCase().replace(/\s/g, "_")}`);
        output += `${chalk7__default.default.gray(staticConfig.name)} ${chalk7__default.default.green("\u2713")}
`;
        ctx.task.output = output;
        capturedScreenshots++;
      } catch (error) {
        ctx.log.debug(`screenshot capture failed for ${JSON.stringify(staticConfig)}; error: ${error}`);
        output += `${chalk7__default.default.gray(staticConfig.name)} ${chalk7__default.default.red("\u2717")}
`;
        ctx.task.output = output;
      }
    }
    yield closeBrowsers(browsers);
    delDir("screenshots");
    return { capturedScreenshots, output };
  });
}
function getImageDimensions(filePath) {
  const buffer = fs5__default.default.readFileSync(filePath);
  let width, height;
  if (buffer.toString("hex", 0, 2) === "ffd8") {
    let offset = 2;
    while (offset < buffer.length) {
      const marker = buffer.toString("hex", offset, offset + 2);
      offset += 2;
      const length = buffer.readUInt16BE(offset);
      if (marker === "ffc0" || marker === "ffc2") {
        height = buffer.readUInt16BE(offset + 3);
        width = buffer.readUInt16BE(offset + 5);
        return { width, height };
      }
      offset += length;
    }
  } else if (buffer.toString("hex", 1, 4) === "504e47") {
    width = buffer.readUInt32BE(16);
    height = buffer.readUInt32BE(20);
    return { width, height };
  }
  return null;
}
function isAllowedImage(filePath) {
  return __async(this, null, function* () {
    try {
      const fileBuffer = fs5__default.default.readFileSync(filePath);
      const isMagicValid = constants_default.MAGIC_NUMBERS.some((magic) => fileBuffer.slice(0, magic.magic.length).equals(magic.magic));
      const metadata = yield sharp__default.default(filePath).metadata();
      if (metadata.format === constants_default.FILE_EXTENSION_GIFS) {
        return false;
      }
      if (metadata.width > 0 && metadata.height > 0) {
        return true;
      }
      if (isMagicValid && metadata.format !== constants_default.FILE_EXTENSION_GIFS) {
        return true;
      }
      return false;
    } catch (error) {
      return false;
    }
  });
}
function uploadScreenshots(ctx) {
  return __async(this, null, function* () {
    const allowedExtensions = ctx.options.fileExtension.map((ext) => `.${ext.trim().toLowerCase()}`);
    let noOfScreenshots = 0;
    function processDirectory(directory, relativePath = "") {
      return __async(this, null, function* () {
        const files = fs5__default.default.readdirSync(directory);
        for (let file of files) {
          const filePath = path2__default.default.join(directory, file);
          const stat = fs5__default.default.statSync(filePath);
          const relativeFilePath = path2__default.default.join(relativePath, file);
          if (stat.isDirectory() && ctx.options.ignorePattern.includes(relativeFilePath)) {
            ctx.log.info(`Ignoring Directory ${relativeFilePath}`);
            continue;
          }
          if (stat.isDirectory()) {
            yield processDirectory(filePath, relativeFilePath);
          } else {
            let fileExtension = path2__default.default.extname(file).toLowerCase();
            if (allowedExtensions.includes(fileExtension)) {
              const isValid = yield isAllowedImage(filePath);
              if (!isValid) {
                ctx.log.info(`File ${filePath} is not a valid ${fileExtension} image or is corrupted. Skipping.`);
                continue;
              }
              let ssId = relativeFilePath;
              if (ctx.options.stripExtension) {
                ssId = path2__default.default.join(relativePath, path2__default.default.basename(file, fileExtension));
              }
              let viewport = "default";
              if (!ctx.options.ignoreResolutions) {
                const dimensions = getImageDimensions(filePath);
                if (!dimensions) {
                  ctx.log.info(`Unable to determine dimensions for image: ${filePath}`);
                } else {
                  const width = dimensions.width;
                  const height = dimensions.height;
                  viewport = `${width}x${height}`;
                }
              }
              yield ctx.client.uploadScreenshot(ctx.build, filePath, ssId, "default", viewport, ctx.log);
              ctx.log.info(`${filePath} : uploaded successfully`);
              noOfScreenshots++;
            } else {
              ctx.log.info(`File ${filePath} has invalid file extension: ${fileExtension}. Skipping`);
            }
          }
        }
      });
    }
    yield processDirectory(ctx.uploadFilePath);
    if (noOfScreenshots == 0) {
      ctx.log.info(`No screenshots uploaded.`);
    } else {
      ctx.log.info(`${noOfScreenshots} screenshots uploaded successfully.`);
    }
  });
}
var captureScreenshots_default = (ctx) => {
  return {
    title: "Capturing screenshots",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        updateLogContext({ task: "capture" });
        let { capturedScreenshots, output } = yield captureScreenshots(ctx2);
        if (capturedScreenshots != ctx2.webStaticConfig.length) {
          throw new Error(output);
        }
        task.title = "Screenshots captured successfully";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk7__default.default.gray(`${error.message}`);
        throw new Error("Capturing screenshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};

// src/commander/capture.ts
var command2 = new commander.Command();
command2.name("capture").description("Capture screenshots of static sites").argument("<file>", "Web static config file").option("--parallel", "Capture parallely on all browsers").action(function(file, _, command5) {
  return __async(this, null, function* () {
    let ctx = ctx_default(command5.optsWithGlobals());
    if (!fs5__default.default.existsSync(file)) {
      console.log(`Error: Web Static Config file ${file} not found.`);
      return;
    }
    try {
      ctx.webStaticConfig = JSON.parse(fs5__default.default.readFileSync(file, "utf8"));
      if (!validateWebStaticConfig(ctx.webStaticConfig))
        throw new Error(validateWebStaticConfig.errors[0].message);
    } catch (error) {
      console.log(`[smartui] Error: Invalid Web Static Config; ${error.message}`);
      return;
    }
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        createBuild_default(),
        captureScreenshots_default(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
var capture_default = command2;
var uploadScreenshots_default = (ctx) => {
  return {
    title: "Uploading screenshots",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        updateLogContext({ task: "upload" });
        yield uploadScreenshots(ctx2);
        task.title = "Screenshots uploaded successfully";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk7__default.default.gray(`${error.message}`);
        throw new Error("Uploading screenshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};

// src/commander/upload.ts
var command3 = new commander.Command();
command3.name("upload").description("Upload screenshots from given directory").argument("<directory>", "Path of the directory").option("-R, --ignoreResolutions", "Ignore resolution").option("-F, --files <extensions>", "Comma-separated list of allowed file extensions", (val) => {
  return val.split(",").map((ext) => ext.trim().toLowerCase());
}).option("-E, --removeExtensions", "Strips file extensions from snapshot names").option("-i, --ignoreDir <patterns>", "Comma-separated list of directories to ignore", (val) => {
  return val.split(",").map((pattern) => pattern.trim());
}).action(function(directory, _, command5) {
  return __async(this, null, function* () {
    let ctx = ctx_default(command5.optsWithGlobals());
    if (!fs5__default.default.existsSync(directory)) {
      console.log(`Error: The provided directory ${directory} not found.`);
      return;
    }
    if (path2__default.default.extname(directory).toLowerCase() === constants_default.FILE_EXTENSION_ZIP) {
      ctx.log.debug(`Error: The provided directory ${directory} is a zip file. Zips are not accepted.`);
      return;
    }
    ctx.uploadFilePath = directory;
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        createBuild_default(),
        uploadScreenshots_default(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
var upload_default = command3;

// src/lib/uploadFigmaDesigns.ts
var uploadFigmaDesigns_default = (ctx) => __async(void 0, null, function* () {
  const depth = ctx.figmaDesignConfig.depth;
  const figmaConfigs = ctx.figmaDesignConfig.figma_config;
  let results = "";
  let figmaFileToken = "";
  const markBaseline = ctx.options.markBaseline;
  const buildName = ctx.options.buildName;
  for (const config of figmaConfigs) {
    figmaFileToken = config.figma_file_token;
    let queryParams = "";
    if (config.figma_ids && config.figma_ids.length > 0) {
      const fileIds = config.figma_ids.join(",");
      queryParams += `?ids=${fileIds}`;
    }
    const authToken = `Basic ${Buffer.from(`${ctx.env.LT_USERNAME}:${ctx.env.LT_ACCESS_KEY}`).toString("base64")}`;
    const responseData = yield ctx.client.getFigmaFilesAndImages(figmaFileToken, ctx.env.FIGMA_TOKEN, queryParams, authToken, depth, markBaseline, buildName, ctx.log);
    if (responseData.data.message == "success") {
      results = responseData.data.message;
    }
  }
  return results;
});

// src/tasks/uploadFigmaDesigns.ts
var uploadFigmaDesigns_default2 = (ctx) => {
  return {
    title: "Uploading Figma Designs",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        updateLogContext({ task: "upload-figma" });
        let results = yield uploadFigmaDesigns_default(ctx2);
        if (results != "success") {
          throw new Error("Uploading Figma designs failed");
        }
        task.title = "Figma designs images uploaded successfully to SmartUI";
        ctx2.log.debug(`Figma designs processed: ${results}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk7__default.default.gray(`${error.message}`);
        throw new Error("Uploading Figma designs failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};

// src/commander/uploadFigma.ts
var command4 = new commander.Command();
command4.name("upload-figma").description("Capture screenshots of static sites").argument("<file>", "figma design config file").option("--markBaseline", "Mark the uploaded images as baseline").option("--buildName <buildName>", "Name of the build").action(function(file, _, command5) {
  return __async(this, null, function* () {
    var _a, _b;
    let ctx = ctx_default(command5.optsWithGlobals());
    if (!fs5__default.default.existsSync(file)) {
      console.log(`Error: Figma Config file ${file} not found.`);
      return;
    }
    try {
      ctx.figmaDesignConfig = JSON.parse(fs5__default.default.readFileSync(file, "utf8"));
      if (!validateFigmaDesignConfig(ctx.figmaDesignConfig)) {
        const validationError = (_b = (_a = validateFigmaDesignConfig.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.message;
        throw new Error(validationError || "Invalid figma design Config");
      }
    } catch (error) {
      console.log(`[smartui] Error: Invalid figma design Config; ${error.message}`);
      return;
    }
    let tasks = new listr2.Listr(
      [
        auth_default(),
        uploadFigmaDesigns_default2()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
var uploadFigma_default = command4;

// src/commander/commander.ts
var program = new commander.Command();
program.name("smartui").description("CLI to help you run your SmartUI tests on LambdaTest platform").version(`v${version}`).option("-c --config <filepath>", "Config file path").addCommand(exec_default2).addCommand(capture_default).addCommand(configWeb).addCommand(configStatic).addCommand(upload_default).addCommand(configFigma).addCommand(uploadFigma_default);
var commander_default = program;
(function() {
  return __async(this, null, function* () {
    let client = new httpClient(env_default());
    let log2 = logger_default;
    try {
      let { data: { latestVersion, deprecated, additionalDescription } } = yield client.checkUpdate(log2);
      log2.info(`
LambdaTest SmartUI CLI v${package_default.version}`);
      log2.info(chalk7__default.default.yellow(`${additionalDescription}`));
      if (deprecated) {
        log2.warn(`This version is deprecated. A new version ${latestVersion} is available!`);
      } else if (package_default.version !== latestVersion) {
        log2.info(chalk7__default.default.green(`A new version ${latestVersion} is available!`));
      } else
        log2.info(chalk7__default.default.gray("https://www.npmjs.com/package/@lambdatest/smartui-cli\n"));
    } catch (error) {
      log2.debug(error);
      log2.info(chalk7__default.default.gray("https://www.npmjs.com/package/@lambdatest/smartui-cli\n"));
    }
    commander_default.parse();
  });
})();
